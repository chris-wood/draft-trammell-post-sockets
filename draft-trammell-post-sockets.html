<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Post Sockets, An Abstract Programming Interface for the Transport Layer</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Abstractions and Terminology"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Association"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Listener"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Remote"/>
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Local"/>
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Path"/>
<link href="#rfc.section.2.6" rel="Chapter" title="2.6 Object"/>
<link href="#rfc.section.2.7" rel="Chapter" title="2.7 Stream"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Abstract Programming Interface"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Address Resolution"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Active Association Creation"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Listener and Passive Association Creation"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Sending Objects"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Receiving Objects"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Events"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Acknowledgments"/>
<link href="#rfc.references" rel="Chapter" title="5 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Trammell, B., Perkins, C., Pauly, T., and M. Kuehlewind" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-trammell-post-sockets-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-10-20" />
  <meta name="dct.abstract" content="[EDITOR&#8217;S NOTE: write me]" />
  <meta name="description" content="[EDITOR&#8217;S NOTE: write me]" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">TAPS Working Group</td>
  <td class="right">B. Trammell</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">ETH Zurich</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">C. Perkins</td>
</tr>
<tr>
  <td class="left">Expires: April 23, 2017</td>
  <td class="right">University of Glasgow</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">T. Pauly</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Apple Inc.</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">M. Kuehlewind</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">ETH Zurich</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">October 20, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Post Sockets, An Abstract Programming Interface for the Transport Layer<br />
  <span class="filename">draft-trammell-post-sockets-00</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>[EDITOR&#8217;S NOTE: write me]</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 23, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Abstractions and Terminology</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Association</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Listener</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Remote</a></li>
<li>2.4.   <a href="#rfc.section.2.4">Local</a></li>
<li>2.5.   <a href="#rfc.section.2.5">Path</a></li>
<li>2.6.   <a href="#rfc.section.2.6">Object</a></li>
<li>2.7.   <a href="#rfc.section.2.7">Stream</a></li>
</ul><li>3.   <a href="#rfc.section.3">Abstract Programming Interface</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Address Resolution</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Active Association Creation</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Listener and Passive Association Creation</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Sending Objects</a></li>
<li>3.5.   <a href="#rfc.section.3.5">Receiving Objects</a></li>
<li>3.6.   <a href="#rfc.section.3.6">Events</a></li>
</ul><li>4.   <a href="#rfc.section.4">Acknowledgments</a></li>
<li>5.   <a href="#rfc.references">Informative References</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">The BSD Unix Sockets API&#8217;s SOCK_STREAM abstraction, by bringing network sockets into the UNIX programming model, allowing anyone who knew how to write programs that dealt with sequential-access files to also write network applications, was a revolution in simplicity. It would not be an overstatement to say that this simple API is the reason the Internet won the protocol wars of the 1980s. SOCK_STREAM is tied to the Transmission Control Protocol (TCP), specified in 1981 <a href="#RFC0793">[RFC0793]</a>. TCP has scaled remarkably well over the past three and a half decades, but its total ubiquity has hidden an uncomfortable fact: the network is not really a file, and stream abstractions are too simplistic for many modern application programming models.</p>
<p id="rfc.section.1.p.2">In the meantime, the nature of Internet access is evolving. Many end-user devices are connected to the Internet via multiple interfaces, which suggests it is time to promote the &#8220;path&#8221; by which a host is connected to a first-order object; we call this &#8220;path primacy&#8221;.</p>
<p id="rfc.section.1.p.3">Implicit multipath communication is available for these multihomed nodes in the present Internet architecture with the Multipath TCP extension (MPTCP) <a href="#RFC6824">[RFC6824]</a>. Since many multihomed nodes are connected to the Internet through access paths with widely different properties with respect to bandwidth, latency and cost, adding explicit path control to MPTCP&#8217;s API would be useful in many situations. Path primacy for cooperation with path elements is also useful in single-homed architectures, such as that proposed by the Path Layer UDP Substrate (PLUS) effort (see <a href="#I-D.trammell-plus-statefulness">[I-D.trammell-plus-statefulness]</a> and <a href="#I-D.trammell-plus-abstract-mech">[I-D.trammell-plus-abstract-mech]</a>).</p>
<p id="rfc.section.1.p.4">Another trend straining the traditional layering of the transport stack associated with the SOCK_STREAM interface is the widespread interest in ubiquitous deployment of encryption to guarantee confidentiality, authenticity, and integrity, in the face of pervasive surveillance <a href="#RFC7258">[RFC7258]</a>. Layering the most widely deployed encryption technology, Transport Layer Security (TLS), strictly atop TCP (i.e., via a TLS library such as OpenSSL that uses the sockets API) requires the encryption-layer handshake to happen after the transport-layer handshake, which increases connection setup latency on the order of one or two round-trip times, an unacceptable delay for many applications. Integrating cryptographic state setup and maintenance into the path abstraction naturally complements efforts in new protocols (e.g. QUIC <a href="#I-D.hamilton-quic-transport-protocol">[I-D.hamilton-quic-transport-protocol]</a>) to mitigate this strict layering.</p>
<p id="rfc.section.1.p.5">From these three starting points &#8211; more flexible abstraction, path primacy, and encryption by default &#8211; we define the Post-Socket Application Programming Interface (API), described in detail in this work. Post is designed to be language, transport protocol, and architecture independent, allowing applications to be written to a common abstract interface, easily ported among different platforms, and used even in environments where transport protocol selection may be done dynamically, as proposed in the IETF&#8217;s Transport Services wotking group (see https://datatracker.ietf.org/wg/taps/charter).</p>
<p id="rfc.section.1.p.6">Post replaces the traditional SOCK_STREAM abstraction with an Object abstraction. Objects can be small (e.g. messages in message-oriented protocols) or large (e.g. an HTTP response containing header and body). It replaces the notions of a socket address and connected socket with an Association with a remote endpoint via set of Paths. Implementation and wire format for transport protocol(s) implementing the Post API are explicitly out of scope for this work; these abstractions need not map directly to implementation-level concepts, and indeed with various amounts of shimming and glue could be implemented with varying success atop any sufficiently flexible transport protocol.</p>
<p id="rfc.section.1.p.7">For compatibility with situations where only strictly stream-oriented transport protocols are available, applications with data streams that cannot be easily split into Objects at the sender, and and for easy porting of the great deal of existing stream-oriented application code to Post, Post also provides a SOCK_STREAM compatible abstraction, unimaginatively named Stream.</p>
<p id="rfc.section.1.p.8">The key features of Post as compared with the existing sockets API are:</p>
<p/>

<ul>
  <li>Explicit Object orientation, with framing and atomicity guarantees for Object transmission.</li>
  <li>Asynchronous reception, allowing all receiver-side interactions to be event-driven.</li>
  <li>Explicit support for multipath transport protocols and network architectures.</li>
  <li>Long-lived Associations, whose lifetimes may not be bound to underlying \ transport connections. This allows associations to cache state and cryptographic key material to enable fast (0-rtt) resumption of communication.</li>
</ul>
<p id="rfc.section.1.p.10">This work is the synthesis of many years of Internet transport protocol research and development. It is heavily inspired by concepts from the Stream Control Transmission Protocol (SCTP) <a href="#RFC4960">[RFC4960]</a>, TCP Minion [EDITOR&#8217;S NOTE: cite], MinimaLT [EDITOR&#8217;S NOTE: cite, and various bulk object transports.  While much of the work for building parts of the protocols needed to implement Post are already ongoing in other IETF working groups (e.g. TAPS, MPTCP, QUIC, TLS), we argue that an abstract programming interface unifying access all these efforts is necessary to fully exploit their potential.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#abstractions-and-terminology" id="abstractions-and-terminology">Abstractions and Terminology</a></h1>
<div id="rfc.figure.1"/>
<div id="fig-abstractions"/>
<pre>
[gratuitously colorful SVG goes here]
</pre>
<p class="figure">Figure 1: Abstractions and relationships in Post Sockets</p>
<p id="rfc.section.2.p.1">Post is based on a small set of abstractions, the relationships among which are shown in Figure <a href="#fig-abstractions">Figure 1</a> and detailed in this section.</p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#association" id="association">Association</a></h1>
<p id="rfc.section.2.1.p.1">An Association is a container for all the state necessary for a local endpoint to communicate with a remote endpoint in an explicitly multipath environment. It contains a set of Paths, certificate(s) for identifying the remote endpoint, certificate(s) and key(s) for identifying the local endpoint to the remote endpoint, and any cached cryptographic state for the communication to the remote endpoint. An Association may have one or more Streams active at any given time. Objects are sent to Associations, as well.</p>
<p id="rfc.section.2.1.p.2">Note that, in contrast to current SOCK_STREAM sockets, Associations are meant to be relatively long-lived. The lifetime of an Association is not bound to the lifetime of any transport-layer connection between the two endpoints; connections may be opened or closed as necessary to support the Streams and Object transmissions required by the application, and the application need not be bothered with the underlying connectivity state unless this is important to the application&#8217;s semantics.</p>
<p id="rfc.section.2.1.p.3">Paths may be dynamically added or removed from an association, as well, as connectivity between the endpoints changes. Cryptographic identifiers and state for endpoints may also be added and removed as necessary due to certificate lifetimes, key rollover, and revocation.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#listener" id="listener">Listener</a></h1>
<p id="rfc.section.2.2.p.1">In many applications, there is a distinction between the active opener (or connection initiator, often a client), and the passive opener (often a server). A Listener represents an endpoint&#8217;s willingness to start Associations in this passive opener/server role. It is, in essence, a one-sided, Path-less Association from which fully-formed Associations can be created.</p>
<p id="rfc.section.2.2.p.2">Listeners work very much like sockets on which the listen(2) call has been called in the SOCK_STREAM API.</p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#remote" id="remote">Remote</a></h1>
<p id="rfc.section.2.3.p.1">A Remote represents all the information required to establish and maintain a connection with the far end of an Association: network-layer address, transport-layer port, information about public keys or certificate authorities used to identify the remote on connection establishment, etc. Each Association is associated with a single Remote, either explicitly by the application (when created by active open) or by the Listener (when created by passive open). The resolution of Remotes from higher-layer information (URIs, hostnames) is architecture-dependent.</p>
<h1 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a> <a href="#local" id="local">Local</a></h1>
<p id="rfc.section.2.4.p.1">A Local represents all the information about the local endpoint necessary to establish an Association or a Listener: interface and port designators, as well as certificates and associated private keys.</p>
<h1 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5.</a> <a href="#path" id="path">Path</a></h1>
<p id="rfc.section.2.5.p.1">A Path represents a local and remote endpoint address, an optional set of intermediary path elements between the local and remote endpoint addresses, and a set of properties associated with the path.</p>
<p id="rfc.section.2.5.p.2">The set of available properties is a function of the underlying network-layer protocols used to expose the properties to the endpoint. However, the following core properties are generally useful for applications and transport layer protocols to choose among paths for specific Objects:</p>
<p/>

<ul>
  <li>Maximum Transmission Unit (MTU): the maximum size of an Object&#8217;s payload (subtracting transport, network, and link layer overhead) which will likely fit into a single frame. Derived from signals sent by path elements, where available, and/or path MTU discovery processes run by the transport layer.</li>
  <li>Latency Expectation: expected one-way delay along the Path. Generally provided by inline measurements performed by the transport layer, as opposed to signaled by path elements.</li>
  <li>Loss Probability Expectation: expected probability of a loss of any given single frame along the Path. Generally provided by inline measurements performed by the transport layer, as opposed to signaled by path elements.</li>
  <li>Available Data Rate Expectation: expected maximum data rate along the Path. May be derived from passive measurements by the transport layer, or from signals from path elements.</li>
  <li>Reserved Data Rate: Committed, reserved data rate for the given Association along the Path. Requires a bandwidth reservation service in the underlying transport and network layer protocol.</li>
  <li>Path Element Membership: Identifiers for some or all nodes along the path, depending on the capabilities of the underlying network layer protocol to provide this.</li>
</ul>
<p id="rfc.section.2.5.p.4">Path properties are generally read-only. MTU is a property of the underlying link-layer technology on each link in the path; latency, loss, and rate expectations are dynamic properties of the network configuration and network traffic conditions; path element membership is a function of network topology. In an explicitly multipath architecture, application and transport layer requirements are met by having multiple paths with different properties to select from. Post can also provide signaling to the path, but this signaling is derived from information provided to the Object abstraction, below.</p>
<h1 id="rfc.section.2.6"><a href="#rfc.section.2.6">2.6.</a> <a href="#object" id="object">Object</a></h1>
<p id="rfc.section.2.6.p.1">Post provides two ways to send data over an Association. We start with the Object abstraction, as a fundamental insight behind the interface is that most applications fundamentally deal in object transport.</p>
<p id="rfc.section.2.6.p.2">An Object is an atomic unit of communication between applications; or in other words, an ordered collection of bytes B0..Bm, such that every byte Bn depends on every other byte in the Object. An object that cannot be delivered in its entirety within the constraints of the network connectivity and the requirements of the application is not delivered at all.</p>
<p id="rfc.section.2.6.p.3">Objects can represent both relatively small structures, such as messages in application-layer protocols built around datagram or message exchange, as well as relatively large structures, such files of arbitrary size in a filesystem.  Objects larger than the MTU on the Path on which they are sent will be segmented into multiple frames. Multiple objects that will fit into a single frame may be concatenated into one frame. There is no preference for transmitting the multiple frames for a given Object in any particular order, or by default, that objects will be delivered in the order sent by the application. This implies that both the sending and receiving endpoint, whether in the application layer or the transport layer, must guarantee storage for the full size of an object.</p>
<p id="rfc.section.2.6.p.4">Three object properties allow applications fine control ordering and reliability requirements in line with application semantics. An Object may have a &#8220;lifetime&#8221; &#8211; a wallclock duration before which the object must be available to the application layer at the remote end. If a lifetime cannot be met, the object is discarded as soon as possible; therefore, Objects with lifetimes are implicitly sent non-reliably, and lifetimes are used to prioritize Object delivery. Lifetimes may be signaled to path elements by the underlying transport, so that path elements that realize a lifetime cannot be met can discard frames containing the object instead of forwarding them.</p>
<p id="rfc.section.2.6.p.5">Second, Objects may have a &#8220;niceness&#8221; &#8211; a category in an unbounded hierarchy most naturally represented as a non-negative integer. By default, Objects are in niceness class 0, or highest priority. Niceness class 1 Objects will yield to niceness class 0 objects, class 2 to class 1, and so on.  Niceness may be translated to a priority signal for exposure to path elements (e.g. DSCP codepoint) to allow prioritization along the path as well as at the sender and receiver. This inversion of normal schemes for expressing priority has a convenient property: priority increases as both niceness and deadline decrease.</p>
<p id="rfc.section.2.6.p.6">An object may have both a niceness and a lifetime &#8211; objects with higher niceness classes will yield to lower classes if resource constraints mean only one can meet the lifetime.</p>
<p id="rfc.section.2.6.p.7">Third, an Object may have &#8220;antecedents&#8221; &#8211; other Objects on which it depends, which must be delivered before it (the &#8220;successor&#8221;) is delivered.  The sending transport uses deadlines, niceness, and antecedents, along with information about the properties of the Paths available, to determine when to send which object down which Path.</p>
<p id="rfc.section.2.6.p.8">When an application has hard semantic requirements that all the frames of a given object be sent down a given Path or Paths, these hard constraints can also be expressed by the application.</p>
<p id="rfc.section.2.6.p.9">After calling the send function, the application can register event handlers to be informed of the transmission status of the object. Specifically, the following properties can be provided:</p>
<p/>

<ul>
  <li>Expected delivery time: provides an estimation of the time when the transport expects to fully deliver the object, given the current conditions on the different paths. This applies to all objects.</li>
  <li>Success probability: provides an estimation of the chances that an object gets fully delivered within its specified lifetime, given current conditions. This applies only to partially reliable objects (i.e., with a non-infinite lifetime).</li>
</ul>
<p id="rfc.section.2.6.p.11">These properties might not be available immediately. The corresponding event handlers will be called as soon as a first estimation is made and every time it is updated.</p>
<h1 id="rfc.section.2.7"><a href="#rfc.section.2.7">2.7.</a> <a href="#stream" id="stream">Stream</a></h1>
<p id="rfc.section.2.7.p.1">The Stream abstraction is provided for two reasons. First, since it is the most like the existing SOCK_STREAM interface, it is the simplest abstraction to be used by applications ported to Post to take advantages of Path primacy.  Second, some environments have connectivity so impaired (by local network operation policy and/or accidental middlebox interference) that only stream- based transport protocols are available, and applications should have the option to use streams directly in these situations.</p>
<p id="rfc.section.2.7.p.2">A Stream is a sequence of bytes B0 .. Bm such that the reception (and delivery to the receiving application of) Bn always depends on Bn-1.  This property is inherited from the BSD UNIX file abstraction, which in turn inherited it from the physical limitations of sequential access media (stacks of punch cards, paper and/or magnetic tape).</p>
<p id="rfc.section.2.7.p.3">A Stream is bound to an Association. Writing a byte to the stream will cause it to be received by the remote, in order, or will cause an error condition and termination of the stream if the byte cannot be delivered. Due to the strong sequential dependence on a stream, streams must always be reliable and ordered. If frames containing Stream data are lost, these must be retransmitted or reconstructed using an error correction technique. If frames containing Stream data arrive out of order, the remote end must buffer them until the unordered frames are received and reassembled.</p>
<p id="rfc.section.2.7.p.4">As with Objects, Streams may have a niceness for prioritization. When mixing Stream and Object data on the same Path in an association, the niceness classes for Streams and Objects are interleaved; e.g. niceness 2 Stream frames will yield to niceness 1 Object frames.</p>
<p id="rfc.section.2.7.p.5">The underlying transport protocol may make whatever use of the Paths and known properties of those Paths it sees fit when transporting a Stream.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#abstract-programming-interface" id="abstract-programming-interface">Abstract Programming Interface</a></h1>
<p id="rfc.section.3.p.1">We now turn to the design of an abstract programming interface to provide a simple interface to Post&#8217;s abstractions, constrained by the following design principles:</p>
<p/>

<ul>
  <li>Flexibility is paramount. So is simplicity. Applications must be given as many controls and as much information as they may need, but they must be able to ignore controls and information irrelevant to their operation. This implies that the &#8220;default&#8221; interface must be no more complicated than BSD sockets, and must do something reasonable.</li>
  <li>A new API cannot be bound to a single transport protocol and expect wide deployment. As the API is transport-independent and may support runtime transport selection, it must impose the minimum possible set of constraints on its underlying transports, though some API features may require underlying transport features to work optimally. It must be possible to implement Post over vanilla TCP in the present Internet architecture.</li>
  <li>Reception is an inherently asynchronous activity. While the API is designed to be as platform-independent as possible, one key insight it is based on is that an object receiver&#8217;s behavior in a packet-switched network is inherently asynchronous, driven by the receipt of packets, and that this asynchronicity must be reflected in the API. The actual implementation of receive and event callbacks will need to be aligned to the method a given platform provides for asynchronous I/O.</li>
</ul>
<p id="rfc.section.3.p.3">[EDITOR&#8217;S NOTE a little more frontmatter to introduce the API; maybe a list of calls?]</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#address-resolution" id="address-resolution">Address Resolution</a></h1>
<p id="rfc.section.3.1.p.1">[EDITOR&#8217;S NOTE given the multiple-architecture focus of the API, this needs to be pretty opaque. turns names into resolved Remotes; there also needs to be a way to get a resolved Local given local address or interface specifier.]</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#active-association-creation" id="active-association-creation">Active Association Creation</a></h1>
<p id="rfc.section.3.2.p.1">Associations can be created two ways: actively by a connection initiator, and passively by a Listener that accepts a connection. Connection initiation uses the associate() entry point:</p>
<p id="rfc.section.3.2.p.2">association = associate(local, remote, receive_handler)</p>
<p id="rfc.section.3.2.p.3">where:</p>
<p/>

<ul>
  <li>local: a resolved Local describing the local identity and interface(s) to use</li>
  <li>remote: a resolved Remote to associate with</li>
  <li>receive_handler: a callback to be invoked when new objects are received; see  <a href="#receiving-objects">Section 3.5</a></li>
</ul>
<p id="rfc.section.3.2.p.5">The returned association has the following additional properties:</p>
<p/>

<ul>
  <li>paths: a set of Paths that the Association can currently use to transport Objects. When the underlying transport connection is closed, this set will be empty. For explicitly multipath architectures and transports, this set may change dynamically during the lifetime of an association, even while it remains connected.</li>
</ul>
<p id="rfc.section.3.2.p.7">Since the existence of an association does not necessarily imply current connection state at both ends of the Association, these objects are durable, and can be cached, migrated, and restored, as long as the mappings to their event handlers are stable. An attempts to send an object or open a stream on a dormant, previously actively-opened association will cause the underlying transport connection state to be resumed.</p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#listener-and-passive-association-creation" id="listener-and-passive-association-creation">Listener and Passive Association Creation</a></h1>
<p id="rfc.section.3.3.p.1">In order to accept new Association requests from clients, a server must create a Listener object, using the listen() entry point:</p>
<p id="rfc.section.3.3.p.2">listener = listen(local, accept_handler)</p>
<p id="rfc.section.3.3.p.3">where:</p>
<p/>

<ul>
  <li>local: resolved Local describing the local identity and interface(s) to use for Associations created by this listener.</li>
  <li>accept_handler: callback to be invoked each time an association is requested by a remote, to finalize setting the association up. Platforms may provide a default here for supporting synchronous association request handling via an object queue.</li>
</ul>
<p id="rfc.section.3.3.p.5">The accept_handler has the following prototype:</p>
<p id="rfc.section.3.3.p.6">accepted = accept_handler(listener, local, remote)</p>
<p id="rfc.section.3.3.p.7">where:</p>
<p/>

<ul>
  <li>local: a resolved Local on which the association request was received.</li>
  <li>remote: a resolved Remote from which the association request was received.</li>
  <li>accepted: flag, true if the handler decided to accept the request, false otherwise.</li>
</ul>
<p id="rfc.section.3.3.p.9">The accept_handler() calls the accept() entry point to finally create the association:</p>
<p id="rfc.section.3.3.p.10">association = accept(listener, local, remote, receive_handler)</p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#sending-objects" id="sending-objects">Sending Objects</a></h1>
<p id="rfc.section.3.4.p.1">Objects are sent using the send() entry point:</p>
<p id="rfc.section.3.4.p.2">send(association, bytes, [lifetime], [niceness], [oid], [antecedent_oids], [paths])}</p>
<p id="rfc.section.3.4.p.3">where:</p>
<p/>

<ul>
  <li>association: the association to send the object on</li>
  <li>bytes: sequence of bytes making up the object. For platforms without bounded byte arrays, this may be implemented as a pointer and a length.</li>
  <li>lifetime: lifetime of the object in milliseconds. This parameter is optional and defaults to infinity (for fully reliable object transport).</li>
  <li>niceness: the object&#8217;s niceness class. This parameter is optional and defaults to zero (for lowest niceness / highest priority)</li>
  <li>oid: opaque identifier for an object, assigned by the application. Used to refer to this object as a subsequently sent object&#8217;s antecedent, or in an ack or expired handler (see <a href="#events">Section 3.6</a>). Optional, defaults to null.</li>
  <li>antecedent_oids: set of object identifiers on which this object depends and which must be sent before this object. Optional, defaults to empty, meaning this object has no antecedent constraints.</li>
  <li>paths: set of paths, as a subset of those available to the association, to explicitly use for this object. Optional, defaults to empty, meaning all paths are acceptable.</li>
</ul>
<p id="rfc.section.3.4.p.5">Calls to send are non-blocking; synchronous send which blocks on remote acknowledgment or expiry of a</p>
<h1 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#receiving-objects" id="receiving-objects">Receiving Objects</a></h1>
<p id="rfc.section.3.5.p.1">An application receives objects via its receive_handler callback, registered at association creation time. This callback has the following prototype:</p>
<p id="rfc.section.3.5.p.2">receive_handler(association, bytes)</p>
<p id="rfc.section.3.5.p.3">where: - association: the association the object was received from.  - bytes: the sequence of bytes making up the object.</p>
<p id="rfc.section.3.5.p.4">For ease of porting synchronous datagram applications, implementations may make a default receive handler available, which allows messages to be synchronously polled from a per-association object queue. If this default is available, the entry point for the polling call is:</p>
<p id="rfc.section.3.5.p.5">bytes = receive_next(association)</p>
<p id="rfc.section.3.5.p.6">\subsection{Creating and Destroying Streams}</p>
<p id="rfc.section.3.5.p.7">[EDITOR&#8217;S NOTE: provide open_stream(), close_stream(), point out that these should be treated exactly like files in the platform.]</p>
<h1 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> <a href="#events" id="events">Events</a></h1>
<p id="rfc.section.3.6.p.1">Message reception is a specific case of an event that can occur on an association. Other events are also available, and the application can register event handlers for each of these. Event handlers are registered via the handle() entry point:</p>
<p id="rfc.section.3.6.p.2">handle(association, event, handler) or</p>
<p id="rfc.section.3.6.p.3">handle(oid, event, handler)</p>
<p id="rfc.section.3.6.p.4">where</p>
<p/>

<ul>
  <li>association: the association to register a handler on, or</li>
  <li>oid: the object identifier to register a handler on</li>
  <li>event: an identifier of the event to register a handler on</li>
  <li>handler: a callback to be invoked when the event occurs, or null if the event should be ignored.</li>
</ul>
<p id="rfc.section.3.6.p.6">The following events are supported; every event handler takes the association, as well as any additional arguments</p>
<p/>

<ul>
  <li>receive (bytes): an object has been received</li>
  <li>path_up (path): a path is newly available</li>
  <li>path_down (path): a path is no longer available</li>
  <li>dormant: no more paths are available, the association is now dormant, and the connection will need to be resumed if further objects are to be sent</li>
  <li>ack (oid): an object was successfully received by the remote</li>
  <li>expired (oid): an object expired before being sent to the remote</li>
</ul>
<p id="rfc.section.3.6.p.8">\subsection{Paths and Path Properties}</p>
<p id="rfc.section.3.6.p.9">[EDITOR&#8217;S NOTE: provide api from which path properties can be read, extensible like handle().]</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.4.p.1">Many thanks to Laurent Chuat and Jason Lee at the Network Security Group at ETH Zurich for contributions to the initial design of Post Sockets.</p>
<p id="rfc.section.4.p.2">This work is partially supported by the European Commission under Horizon 2020 grant agreement no. 688421 Measurement and Architecture for a Middleboxed Internet (MAMI), and by the Swiss State Secretariat for Education, Research, and Innovation under contract no. 15.0268. This support does not imply endorsement.</p>
<h1 id="rfc.references"><a href="#rfc.references">5.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.hamilton-quic-transport-protocol">[I-D.hamilton-quic-transport-protocol]</b>
      </td>
      <td class="top"><a>Hamilton, R.</a>, <a>Iyengar, J.</a>, <a>Swett, I.</a> and <a>A. Wilk</a>, "<a href="http://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-00">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-hamilton-quic-transport-protocol-00, July 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.trammell-plus-abstract-mech">[I-D.trammell-plus-abstract-mech]</b>
      </td>
      <td class="top"><a>Trammell, B.</a>, "<a href="http://tools.ietf.org/html/draft-trammell-plus-abstract-mech-00">Abstract Mechanisms for a Cooperative Path Layer under Endpoint Control</a>", Internet-Draft draft-trammell-plus-abstract-mech-00, September 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.trammell-plus-statefulness">[I-D.trammell-plus-statefulness]</b>
      </td>
      <td class="top"><a>Kuehlewind, M.</a>, <a>Trammell, B.</a> and <a>J. Hildebrand</a>, "<a href="http://tools.ietf.org/html/draft-trammell-plus-statefulness-00">Transport-Independent Path Layer State Management</a>", Internet-Draft draft-trammell-plus-statefulness-00, October 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC0793">[RFC0793]</b>
      </td>
      <td class="top"><a>Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4960">[RFC4960]</b>
      </td>
      <td class="top"><a>Stewart, R.</a>, "<a href="http://tools.ietf.org/html/rfc4960">Stream Control Transmission Protocol</a>", RFC 4960, DOI 10.17487/RFC4960, September 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6824">[RFC6824]</b>
      </td>
      <td class="top"><a>Ford, A.</a>, <a>Raiciu, C.</a>, <a>Handley, M.</a> and <a>O. Bonaventure</a>, "<a href="http://tools.ietf.org/html/rfc6824">TCP Extensions for Multipath Operation with Multiple Addresses</a>", RFC 6824, DOI 10.17487/RFC6824, January 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7258">[RFC7258]</b>
      </td>
      <td class="top"><a>Farrell, S.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc7258">Pervasive Monitoring Is an Attack</a>", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May 2014.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> 
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span class="vcardline">School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow  G12 8QQ</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@cperkins.net">csp@cperkins.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Tommy Pauly</span> 
	  <span class="n hidden">
		<span class="family-name">Pauly</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	
  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> 
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@tik.ee.ethz.ch">mirja.kuehlewind@tik.ee.ethz.ch</a></span>

  </address>
</div>

</body>
</html>
